* Week 3
** 06/10/17
*** Look at edit distance based metric
- weighted edited so that adding/removing weight from an edge counts as an edit in the distance metric
- Removing nodes/edges also counts to edit distance
- https://link.springer.com/content/pdf/10.1007%2Fs10044-008-0141-y.pdf

*** Transform graph to metric space
- Gromovâ€“Hausdorff
- Similar graphs give similar values
- Each node with edges it is connected to and their weights

*** Lobster graph as undirected tree
- Undirected tree is a tree where root is not known
- An undirected graph with no cycles is an undirected tree
- An find less computationally complex algorithm for undirected tree distance rather than graph distance

*** GUI tool to draw graphs and export to .dot files
- d3.js 
- networkx

*** Human pose graph matching papers
- Good ideas that have been tried or bad ones to avoid
- 

* Week 4

** Before meetings
*** Human pose graph matching http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.592.4170&rep=rep1&type=pdf
- Graph matching algorithm used: Algorithm for error-tolerant subgraph isomorphism detection http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=682179
- Store database of model graphs. Graph matching algorithm could return multiple matches from database because it only looks at topology
- Decision trees used to further filter matches. Example graphs are created for decision to learn. 

*** Graph creation software
- Gephi to draw graphs, it can export drawn graphs into a number of data formats. 

** 12/10/17
*** Create graphs from lobsters to try matching
- Have some sample graphs to be able to run through nauty and try the matching
- augment hand made graphs by adding mistakes (wrong labels or vertices)
- try to match mistake graphs with correct ones
- generate the mistake graphs and try to match them all to see which of the generated ones may match at all

*** software 
- graphgrep
- nauty
- see how fast it will take to match

*** From list of vertices
-> generate possible configurations
-> match with database annotated graphs
-> best matching ones go to 2nd step of matching (i.e, decision tree)

*** From this look into training decision tree

*** Start form subgraphs
- Instead of creating entire lobsters initially
- start with smaller subgraphs and match those 
- create the larger graph from subgraphs that are already matched and labelled
- more reliable to detect subgraph rather than entire lobster at once


* Week 5

** 27/10/17

*** other algorithm
- APPAGTO
- nauty

*** Graphgrep
- try very large dataset to see time taken
- say around 1000 in database
- combinations of all subgraphs
- see if theres any scaling issues
- subgraphs add into the larger lobster graph
- try subgraphs in database with larger query

contrast different approaches

Changes needed from fuse of subgraph to match to larger graph

know that we can find a number of subgraphs in the images
- we will know that subgraphs are valid because matched

next week - define cost fucntion
- different cost functions
- how many nodes found
- angles and distances of edges

** APPAGATO
*** Approximate network querying
- Find query occurances among all possible with the maximum combined similarity.
- Similarity here means both the similarity between nodes and cost measuring of the differences between nodes and edges

1. Try the APPAGTO algorithm
2. see subgraph matching in graphgrep or nauty -> gives list of matched subgraphs -> cost function

* Week 6

** 03/11/17

*** Matching with errors
- Match subgraphs with errors or variations
- Include filter with probabilities with nodes and edges fitting

*** Add ranking with the probabilities from query
- For each classification of node have an associated probability
- Match all in database
- Naive bayes classifier -> cost of matching (probability the labelling is correct)
    - Probability of each feature and multiply them together
    - When matched the node probabilities will be the same, but combination of nodes/edges and angles will give different probabilities.
    - Gaussian for length matching
- Pick strongest nodes/subgraph from probabilities.



Go back after getting subgraph to get graph properties like edge length and angles.

With list of matched and labelled subgraphs -> building together into whole lobster.
